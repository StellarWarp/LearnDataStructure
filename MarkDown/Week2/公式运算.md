# 公式运算

## 公式类的设计

### 数据

```cpp
string expression;//原始数据
queue<OperateObject>Expression;//存储公式
bool err = false;//存在错误
```

队列Expression中储存后缀表达式

### OperateObject运算对象

将运算符、变量、常量等转化为运算对象以方便操作

储存类型与数据

对外设置转换接口

```cpp
struct OperateObject
	{
    //整数 浮点数 变量 一元运算符 二元运算符 括号 未知
    enum OperateType { i, f, v, monadic, dyadic, parentheses, unknow } type;
    string value;

    OperateObject(char*& exp_ptr);
    OperateObject(VarT var)
    VarT GetValue()
    };

```

### 运算符优先级

```cpp
	enum priority { p4, p3, p2, p1, p0 };

	int Priority(OperateObject op)
	{
		if (op.type == OperateObject::monadic)
		{
			return p0;
		}
		if (op.value == "*" || op.value == "/")
		{
			return p1;
		}
		if (op.value == "+" || op.value == "-")
		{
			return p2;
		}
		if (op.value == ",")
		{
			return p3;
		}
	}
```

### 错误处理

```cpp
void ProcessError(string err_info)
	{
		expression = "err";
		err = true;
		cerr << "Invalid expression : " << err_info << endl;
		while (!Expression.empty())
		{
			Expression.pop();
		}
	}
bool Check()
	{
		return !err;
	}
```

### 后缀表达式的转化

先将原始数据转化成OperateObject存入formula_cache中

而后从formula_cache取出缓存的对象进行后缀表达式的转化

并在转化过程中检查错误

```cpp
queue<OperateObject> formula_cache;//原公式缓存
stack<OperateObject> formula_stack;//栈

//括号数量检查
{
    int p_l{};//左括号数量
    int p_r{};//右括号数量
    for (auto c : exp)
    {
        if (c == '(') p_l++;
        else if (c == ')')p_r++;
    }
    if (p_l != p_r)
    {
        ProcessError("parentheses matching fail");
        return;
    }
}
char* exp_ptr = &exp[0];
//翻译成操作对象
while (*exp_ptr)
{
    formula_cache.push(OperateObject(exp_ptr));
    //错误处理
    if (formula_cache.back().type == OperateObject::unknow)
    {
        ProcessError("Unknow object");
        return;
    }
}

//转化成后缀表达式
bool infunction = false;
OperateObject operateObject;
while (!formula_cache.empty())
{
    operateObject = formula_cache.front();
    formula_cache.pop();
    //不支持符号
    if (operateObject.type == OperateObject::v)
    {
        ProcessError("do not support symbols");
        return;
    }
    //括号
    if (operateObject.type == OperateObject::parentheses)
    {
        if (operateObject.value == "(")
        {
            formula_stack.push(operateObject);//压入括号
        }
        else if (operateObject.value == ")")
        {
            //错误检查
            while (!formula_stack.empty() && formula_stack.top().value != "(")
            {
                Expression.push(formula_stack.top());//弹出括号里运算
                formula_stack.pop();
            }
            if (formula_stack.empty())
            {
                ProcessError("parentheses matching fail");
                return;
            }
            formula_stack.pop();//弹出括号
            if (infunction)
            {
                Expression.push(formula_stack.top());//输出函数
            }
        }
        continue;
    }
    //运算符
    else if (operateObject.type == OperateObject::dyadic)
    {
        //负号处理
        if (Expression.empty() || formula_stack.empty() || formula_stack.top().value == "(")
        {
            if (operateObject.value == "-")
            {
                operateObject.type = OperateObject::monadic;
            }
        }
        //优先级低 弹出
        while (!formula_stack.empty() && formula_stack.top().value != "(" && (Priority(operateObject) <= Priority(formula_stack.top())))
        {
            if (formula_stack.top().value != ",")
                Expression.push(formula_stack.top());
            formula_stack.pop();
        }
        //优先级高 入栈
        formula_stack.push(operateObject);
        //错误检查
        if (formula_cache.empty() || formula_cache.front().type == operateObject.type)
        {
            ProcessError("invalid usage of operator");
            return;
        }
        continue;
    }
    //变量
    else
    {
        Expression.push(operateObject);
        //错误检查//!
        if (!formula_cache.empty())
            if (formula_cache.front().type != OperateObject::dyadic &&
                formula_cache.front().type != OperateObject::monadic &&
                formula_cache.front().value != ")")
            {
                ProcessError("lack of operator");
                return;
            }
        continue;
    }
}
//将栈中剩余的输出
while (!formula_stack.empty())
{
    Expression.push(formula_stack.top());
    formula_stack.pop();
}

expression = exp;//储存原始数据
```

### 后缀表达式的计算

```cpp
		queue<OperateObject> exp = Expression;
		stack<OperateObject> calculate_stack;
		while (!exp.empty())
		{
			OperateObject obj = exp.front(); exp.pop();
			if (obj.type == OperateObject::i)
			{
				calculate_stack.push(obj);
			}
			else if (obj.type == OperateObject::dyadic)
			{
				VarT value1{};
				VarT value2{};
				VarT result{};
				value1 = calculate_stack.top().GetValue(); calculate_stack.pop();
				value2 = calculate_stack.top().GetValue(); calculate_stack.pop();
				if (obj.value == "+")
				{
					result = value2 + value1;
				}
				else if (obj.value == "-")
				{
					result = value2 - value1;
				}
				else if (obj.value == "*")
				{
					result = value2 * value1;
				}
				else if (obj.value == "/")
				{
					if (value1 == 0)
					{
						ProcessError("division by zero");
						return VarT{};
					}
					result = value2 / value1;
				}
				calculate_stack.push(OperateObject(result));
			}
			else if (obj.type == OperateObject::monadic)
			{
				VarT value = calculate_stack.top().GetValue(); calculate_stack.pop();
				VarT result{};
				if (obj.value == "-")
				{
					result = -value;
				}

				calculate_stack.push(OperateObject(result));
			}
		}
		if (!calculate_stack.empty())
			return calculate_stack.top().GetValue();
		else
		{
			ProcessError("empty expression");
			return VarT{};
		}
```



## 运行测试

### 正常输入

> Input expression support integer only
>
> Expression : 2+3*3*(2+2*(-2+1)-9)
> -79
>
> Expression : 2/4+1+(-9+8)
> 0

### 异常输入

> Expression : +
> Invalid expression : invalid usage of operator
>
> Expression : -
> Invalid expression : invalid usage of operator
>
> Expression : )1+1(
> Invalid expression : parentheses matching fail
>
> Expression : (123()
> Invalid expression : parentheses matching fail
>
> Expression : 12(1)
> Invalid expression : lack of operator
>
> Expression : 23/0
> Invalid expression : division by zero
> 0
>
> Expression : 23**2
> Invalid expression : invalid usage of operator
>
> Expression : @434
> Do not support such operation
> Invalid expression : Unknow object
>
> Expression : abc+1
> Invalid expression : do not support symbols
>
> Expression : 测试+322-1
> Invalid expression : empty expression
> 0
>
> Expression : 2123211233+2312312313123
> integer overflow
> -24272416

