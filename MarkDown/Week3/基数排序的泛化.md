## 思路

通过对数据类型进行逐字节的操作以实现排序

或者说是将一字节作为基数，即基数是2^8=256

## unit类

为了方便我们进行数据操作

定义一类

将数据拷贝进类的字节数组data_array中

为了方便起见，使用无符号的unsigned char作为其类型

使用p指针来指向当前的排序的字节

当排序完成后，我们可以通过map_ptr，完成此unit类到原始数据的映射

```cpp
template<class T>
class unit
{
	T* map_ptr;
	unsigned char* data_array;
	unsigned char* p;
public:
	unit()
	{
		data_array = new unsigned char[sizeof(T)]{};
	}
	inline void set_data(T& data)
	{
		memcpy(data_array, &data, sizeof(T));
		p = data_array + sizeof(T) - 1;
		map_ptr = &data;
	}
	inline unsigned char get()
	{
		return *p;
	}
	inline void next()
	{
		p--;
	}
	inline T& map_array()
	{
		return *map_ptr;
	}
	~unit()
	{
		delete[] data_array;
	}
};
```

## 准备

首先要做的是完成原始数据到所定义的类的映射

此外由于直接拷贝类的开销较大，考虑使用指针作为基数排序的运算数组元素

```cpp
unit<T>* Array = new unit<T>[size];
for (int i = 0; i < size; i++)
{
    Array[i].set_data(a[i]);
}
unit<T>** ordering_list = new unit<T>*[size];
for (int i = 0; i < size; i++)
{
    ordering_list[i] = Array + i;
}
const int base_num = 1 << 8;
unsigned int counter[base_num]{};
unit<T>** temp_array = new unit<T>*[size];//辅助数组
```

## 核心算法

核心算法与一般的基数排序基本相同

```cpp
//基排序
	for (int t = 0; t < sizeof(T); t++)
	{
		memset(counter, 0, sizeof(counter));
		for (int i = 0; i < size; i++)
			counter[ordering_list[i]->get()]++;
		for (int i = 1; i < base_num; i++)
			counter[i] = counter[i - 1] + counter[i];
		unit<T>** p = ordering_list;
		for (int i = 0; i < size; i++)
		{
			unsigned char k = ordering_list[i]->get();
			temp_array[counter[k] - 1] = ordering_list[i];
			counter[k]--;
			ordering_list[i]->next();
		}
		memcpy(ordering_list, temp_array, sizeof(T*) * size);
	}
```

## 映射

将数据映射到一个新的数组再覆盖原数组

```cpp
	T* b = new T[size];
	for (int i = 0; i < size; i++)
	{
		b[i] = ordering_list[i]->map_array();
	}
	memcpy(a, b, sizeof(T) * size);
```

最后回收空间

```cpp
	delete[] b;
	delete[] Array;
	delete[] ordering_list;
```



## 符号问题

因为排序中所要处理的常常是有符号的数

所以如果直接使用此算法排序的话，便会造成负数排在正数后面的问题

这个问题可以在映射阶段解决

把负数部分拷贝到原数组的前边，再拷贝正数部分

```cpp
if (_signed)
{
    int filp_pos{};
    for (int i = 0; i < size; i++)
    {
        if (b[i] < 0)
        {
            filp_pos = i;
            break;
        }
    }
    memcpy(a, b + filp_pos, sizeof(T) * (size - filp_pos));//负数
    memcpy(a + (size - filp_pos) , b, sizeof(T) * filp_pos);//正数
}
else
    memcpy(a, b, sizeof(T) * size);
```

## 其它问题

因为使用了类，所以在进行大量数据的排序时，内存开销较大，在一定程度上拖累的基数排序的性能

## 完整实现

```cpp
template<class T>
class unit
{
	T* map_ptr;
	unsigned char* data_array;
	unsigned char* p;
	//int counted_char = 0;
	//int lenth = 0;
public:
	unit()
	{
		data_array = new unsigned char[sizeof(T)]{};
	}
	inline void set_data(T& data)
	{
		memcpy(data_array, &data, sizeof(T));
		//for (int i = sizeof(T) - 1; i >= 0; i--)
		//{
		//	if (data_array[i]) lenth = sizeof(T) - i;
		//}
		p = data_array + sizeof(T) - 1;
		map_ptr = &data;
	}
	inline unsigned char get()
	{
		return *p;
	}
	inline void next()
	{
		p--;
	}
	inline T& map_array()
	{
		return *map_ptr;
	}
	~unit()
	{
		delete[] data_array;
	}
};

template<class T, bool _signed = true>
void RadixCountSort(T a[], int size)
{
	unit<T>* Array = new unit<T>[size];
	for (int i = 0; i < size; i++)
	{
		Array[i].set_data(a[i]);
	}
	unit<T>** ordering_list = new unit<T>*[size];
	for (int i = 0; i < size; i++)
	{
		ordering_list[i] = Array + i;
	}
	const int base_num = 1 << 8;
	unsigned int counter[base_num]{};
	unit<T>** temp_array = new unit<T>*[size];
	//基排序
	for (int t = 0; t < sizeof(T); t++)
	{
		memset(counter, 0, sizeof(counter));
		for (int i = 0; i < size; i++)
			counter[ordering_list[i]->get()]++;
		for (int i = 1; i < base_num; i++)
			counter[i] = counter[i - 1] + counter[i];
		unit<T>** p = ordering_list;
		//unit<T>* (*test)[10] = (unit<T>*(*)[10])ordering_list;
		for (int i = 0; i < size; i++)
		{
			unsigned char k = ordering_list[i]->get();
			temp_array[counter[k] - 1] = ordering_list[i];
			counter[k]--;
			ordering_list[i]->next();
		}
		memcpy(ordering_list, temp_array, sizeof(T*) * size);
	}
	T* b = new T[size];
	for (int i = 0; i < size; i++)
	{
		b[i] = ordering_list[i]->map_array();
	}
	if (_signed)
	{
		int filp_pos{};
		for (int i = 0; i < size; i++)
		{
			if (b[i] < 0)
			{
				filp_pos = i;
				break;
			}
		}
		memcpy(a, b + filp_pos, sizeof(T) * (size - filp_pos));//负数
		memcpy(a + (size - filp_pos) , b, sizeof(T) * filp_pos);//正数
	}
	else
		memcpy(a, b, sizeof(T) * size);
	delete[] b;
	delete[] Array;
	delete[] ordering_list;
}

```

